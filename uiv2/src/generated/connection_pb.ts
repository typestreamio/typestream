// @generated by protoc-gen-es v1.10.1 with parameter "target=ts"
// @generated from file connection.proto (package io.typestream.grpc, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3, protoInt64, Timestamp } from "@bufbuild/protobuf";

/**
 * @generated from enum io.typestream.grpc.DatabaseType
 */
export enum DatabaseType {
  /**
   * @generated from enum value: DATABASE_TYPE_UNSPECIFIED = 0;
   */
  DATABASE_TYPE_UNSPECIFIED = 0,

  /**
   * @generated from enum value: POSTGRES = 1;
   */
  POSTGRES = 1,

  /**
   * @generated from enum value: MYSQL = 2;
   */
  MYSQL = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(DatabaseType)
proto3.util.setEnumType(DatabaseType, "io.typestream.grpc.DatabaseType", [
  { no: 0, name: "DATABASE_TYPE_UNSPECIFIED" },
  { no: 1, name: "POSTGRES" },
  { no: 2, name: "MYSQL" },
]);

/**
 * @generated from enum io.typestream.grpc.ConnectionState
 */
export enum ConnectionState {
  /**
   * @generated from enum value: CONNECTION_STATE_UNSPECIFIED = 0;
   */
  CONNECTION_STATE_UNSPECIFIED = 0,

  /**
   * @generated from enum value: CONNECTED = 1;
   */
  CONNECTED = 1,

  /**
   * @generated from enum value: DISCONNECTED = 2;
   */
  DISCONNECTED = 2,

  /**
   * @generated from enum value: ERROR = 3;
   */
  ERROR = 3,

  /**
   * @generated from enum value: CONNECTING = 4;
   */
  CONNECTING = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(ConnectionState)
proto3.util.setEnumType(ConnectionState, "io.typestream.grpc.ConnectionState", [
  { no: 0, name: "CONNECTION_STATE_UNSPECIFIED" },
  { no: 1, name: "CONNECTED" },
  { no: 2, name: "DISCONNECTED" },
  { no: 3, name: "ERROR" },
  { no: 4, name: "CONNECTING" },
]);

/**
 * Database connection configuration
 *
 * @generated from message io.typestream.grpc.DatabaseConnectionConfig
 */
export class DatabaseConnectionConfig extends Message<DatabaseConnectionConfig> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * @generated from field: io.typestream.grpc.DatabaseType database_type = 3;
   */
  databaseType = DatabaseType.DATABASE_TYPE_UNSPECIFIED;

  /**
   * Hostname for server health checks (e.g., "localhost")
   *
   * @generated from field: string hostname = 4;
   */
  hostname = "";

  /**
   * @generated from field: string port = 5;
   */
  port = "";

  /**
   * @generated from field: string database = 6;
   */
  database = "";

  /**
   * @generated from field: string username = 7;
   */
  username = "";

  /**
   * @generated from field: string password = 8;
   */
  password = "";

  /**
   * Hostname for Kafka Connect connectors (e.g., "postgres" in Docker)
   *
   * @generated from field: string connector_hostname = 9;
   */
  connectorHostname = "";

  constructor(data?: PartialMessage<DatabaseConnectionConfig>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "io.typestream.grpc.DatabaseConnectionConfig";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "database_type", kind: "enum", T: proto3.getEnumType(DatabaseType) },
    { no: 4, name: "hostname", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "port", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "database", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "username", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 8, name: "password", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 9, name: "connector_hostname", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DatabaseConnectionConfig {
    return new DatabaseConnectionConfig().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DatabaseConnectionConfig {
    return new DatabaseConnectionConfig().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DatabaseConnectionConfig {
    return new DatabaseConnectionConfig().fromJsonString(jsonString, options);
  }

  static equals(a: DatabaseConnectionConfig | PlainMessage<DatabaseConnectionConfig> | undefined, b: DatabaseConnectionConfig | PlainMessage<DatabaseConnectionConfig> | undefined): boolean {
    return proto3.util.equals(DatabaseConnectionConfig, a, b);
  }
}

/**
 * Connection status (includes config for UI to use when creating JDBC sinks)
 *
 * @generated from message io.typestream.grpc.ConnectionStatus
 */
export class ConnectionStatus extends Message<ConnectionStatus> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: string name = 2;
   */
  name = "";

  /**
   * @generated from field: io.typestream.grpc.ConnectionState state = 3;
   */
  state = ConnectionState.CONNECTION_STATE_UNSPECIFIED;

  /**
   * @generated from field: string error = 4;
   */
  error = "";

  /**
   * @generated from field: google.protobuf.Timestamp last_checked = 5;
   */
  lastChecked?: Timestamp;

  /**
   * Full config for JDBC sink creation
   *
   * @generated from field: io.typestream.grpc.DatabaseConnectionConfig config = 6;
   */
  config?: DatabaseConnectionConfig;

  constructor(data?: PartialMessage<ConnectionStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "io.typestream.grpc.ConnectionStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "state", kind: "enum", T: proto3.getEnumType(ConnectionState) },
    { no: 4, name: "error", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "last_checked", kind: "message", T: Timestamp },
    { no: 6, name: "config", kind: "message", T: DatabaseConnectionConfig },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConnectionStatus {
    return new ConnectionStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConnectionStatus {
    return new ConnectionStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConnectionStatus {
    return new ConnectionStatus().fromJsonString(jsonString, options);
  }

  static equals(a: ConnectionStatus | PlainMessage<ConnectionStatus> | undefined, b: ConnectionStatus | PlainMessage<ConnectionStatus> | undefined): boolean {
    return proto3.util.equals(ConnectionStatus, a, b);
  }
}

/**
 * Register connection for monitoring
 *
 * @generated from message io.typestream.grpc.RegisterConnectionRequest
 */
export class RegisterConnectionRequest extends Message<RegisterConnectionRequest> {
  /**
   * @generated from field: io.typestream.grpc.DatabaseConnectionConfig connection = 1;
   */
  connection?: DatabaseConnectionConfig;

  constructor(data?: PartialMessage<RegisterConnectionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "io.typestream.grpc.RegisterConnectionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "connection", kind: "message", T: DatabaseConnectionConfig },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RegisterConnectionRequest {
    return new RegisterConnectionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RegisterConnectionRequest {
    return new RegisterConnectionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RegisterConnectionRequest {
    return new RegisterConnectionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: RegisterConnectionRequest | PlainMessage<RegisterConnectionRequest> | undefined, b: RegisterConnectionRequest | PlainMessage<RegisterConnectionRequest> | undefined): boolean {
    return proto3.util.equals(RegisterConnectionRequest, a, b);
  }
}

/**
 * @generated from message io.typestream.grpc.RegisterConnectionResponse
 */
export class RegisterConnectionResponse extends Message<RegisterConnectionResponse> {
  /**
   * @generated from field: bool success = 1;
   */
  success = false;

  /**
   * @generated from field: string error = 2;
   */
  error = "";

  /**
   * @generated from field: io.typestream.grpc.ConnectionStatus status = 3;
   */
  status?: ConnectionStatus;

  constructor(data?: PartialMessage<RegisterConnectionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "io.typestream.grpc.RegisterConnectionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "success", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "error", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "status", kind: "message", T: ConnectionStatus },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RegisterConnectionResponse {
    return new RegisterConnectionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RegisterConnectionResponse {
    return new RegisterConnectionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RegisterConnectionResponse {
    return new RegisterConnectionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: RegisterConnectionResponse | PlainMessage<RegisterConnectionResponse> | undefined, b: RegisterConnectionResponse | PlainMessage<RegisterConnectionResponse> | undefined): boolean {
    return proto3.util.equals(RegisterConnectionResponse, a, b);
  }
}

/**
 * Unregister connection
 *
 * @generated from message io.typestream.grpc.UnregisterConnectionRequest
 */
export class UnregisterConnectionRequest extends Message<UnregisterConnectionRequest> {
  /**
   * @generated from field: string connection_id = 1;
   */
  connectionId = "";

  constructor(data?: PartialMessage<UnregisterConnectionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "io.typestream.grpc.UnregisterConnectionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "connection_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UnregisterConnectionRequest {
    return new UnregisterConnectionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UnregisterConnectionRequest {
    return new UnregisterConnectionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UnregisterConnectionRequest {
    return new UnregisterConnectionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: UnregisterConnectionRequest | PlainMessage<UnregisterConnectionRequest> | undefined, b: UnregisterConnectionRequest | PlainMessage<UnregisterConnectionRequest> | undefined): boolean {
    return proto3.util.equals(UnregisterConnectionRequest, a, b);
  }
}

/**
 * @generated from message io.typestream.grpc.UnregisterConnectionResponse
 */
export class UnregisterConnectionResponse extends Message<UnregisterConnectionResponse> {
  /**
   * @generated from field: bool success = 1;
   */
  success = false;

  /**
   * @generated from field: string error = 2;
   */
  error = "";

  constructor(data?: PartialMessage<UnregisterConnectionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "io.typestream.grpc.UnregisterConnectionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "success", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "error", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UnregisterConnectionResponse {
    return new UnregisterConnectionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UnregisterConnectionResponse {
    return new UnregisterConnectionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UnregisterConnectionResponse {
    return new UnregisterConnectionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: UnregisterConnectionResponse | PlainMessage<UnregisterConnectionResponse> | undefined, b: UnregisterConnectionResponse | PlainMessage<UnregisterConnectionResponse> | undefined): boolean {
    return proto3.util.equals(UnregisterConnectionResponse, a, b);
  }
}

/**
 * Get all connection statuses
 *
 * @generated from message io.typestream.grpc.GetConnectionStatusesRequest
 */
export class GetConnectionStatusesRequest extends Message<GetConnectionStatusesRequest> {
  constructor(data?: PartialMessage<GetConnectionStatusesRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "io.typestream.grpc.GetConnectionStatusesRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetConnectionStatusesRequest {
    return new GetConnectionStatusesRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetConnectionStatusesRequest {
    return new GetConnectionStatusesRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetConnectionStatusesRequest {
    return new GetConnectionStatusesRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetConnectionStatusesRequest | PlainMessage<GetConnectionStatusesRequest> | undefined, b: GetConnectionStatusesRequest | PlainMessage<GetConnectionStatusesRequest> | undefined): boolean {
    return proto3.util.equals(GetConnectionStatusesRequest, a, b);
  }
}

/**
 * @generated from message io.typestream.grpc.GetConnectionStatusesResponse
 */
export class GetConnectionStatusesResponse extends Message<GetConnectionStatusesResponse> {
  /**
   * @generated from field: repeated io.typestream.grpc.ConnectionStatus statuses = 1;
   */
  statuses: ConnectionStatus[] = [];

  constructor(data?: PartialMessage<GetConnectionStatusesResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "io.typestream.grpc.GetConnectionStatusesResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "statuses", kind: "message", T: ConnectionStatus, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetConnectionStatusesResponse {
    return new GetConnectionStatusesResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetConnectionStatusesResponse {
    return new GetConnectionStatusesResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetConnectionStatusesResponse {
    return new GetConnectionStatusesResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetConnectionStatusesResponse | PlainMessage<GetConnectionStatusesResponse> | undefined, b: GetConnectionStatusesResponse | PlainMessage<GetConnectionStatusesResponse> | undefined): boolean {
    return proto3.util.equals(GetConnectionStatusesResponse, a, b);
  }
}

/**
 * Test a connection one-shot
 *
 * @generated from message io.typestream.grpc.TestConnectionRequest
 */
export class TestConnectionRequest extends Message<TestConnectionRequest> {
  /**
   * @generated from field: io.typestream.grpc.DatabaseConnectionConfig connection = 1;
   */
  connection?: DatabaseConnectionConfig;

  constructor(data?: PartialMessage<TestConnectionRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "io.typestream.grpc.TestConnectionRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "connection", kind: "message", T: DatabaseConnectionConfig },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestConnectionRequest {
    return new TestConnectionRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestConnectionRequest {
    return new TestConnectionRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestConnectionRequest {
    return new TestConnectionRequest().fromJsonString(jsonString, options);
  }

  static equals(a: TestConnectionRequest | PlainMessage<TestConnectionRequest> | undefined, b: TestConnectionRequest | PlainMessage<TestConnectionRequest> | undefined): boolean {
    return proto3.util.equals(TestConnectionRequest, a, b);
  }
}

/**
 * @generated from message io.typestream.grpc.TestConnectionResponse
 */
export class TestConnectionResponse extends Message<TestConnectionResponse> {
  /**
   * @generated from field: bool success = 1;
   */
  success = false;

  /**
   * @generated from field: string error = 2;
   */
  error = "";

  /**
   * @generated from field: int64 latency_ms = 3;
   */
  latencyMs = protoInt64.zero;

  constructor(data?: PartialMessage<TestConnectionResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "io.typestream.grpc.TestConnectionResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "success", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "error", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "latency_ms", kind: "scalar", T: 3 /* ScalarType.INT64 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TestConnectionResponse {
    return new TestConnectionResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TestConnectionResponse {
    return new TestConnectionResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TestConnectionResponse {
    return new TestConnectionResponse().fromJsonString(jsonString, options);
  }

  static equals(a: TestConnectionResponse | PlainMessage<TestConnectionResponse> | undefined, b: TestConnectionResponse | PlainMessage<TestConnectionResponse> | undefined): boolean {
    return proto3.util.equals(TestConnectionResponse, a, b);
  }
}

